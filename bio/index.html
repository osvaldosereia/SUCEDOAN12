<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SISTEMAS | Studio 300 Pro</title>
    <meta name="description" content="Editor 300x300 Híbrido: Lanczos3 Resampling & Smart Compression.">
    <meta name="theme-color" content="#2563eb">
    
    <!-- ENGINE EXTERNA DE ALTA QUALIDADE (Lanczos3) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pica/9.0.1/pica.min.js"></script>
    
    <style>
        /* --- CSS CLASSLESS & MINIMALIST --- */
        :root {
            --bg: #f8fafc;
            --surface: #ffffff;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --brand: #2563eb;
            --brand-dark: #1e40af;
            --action: #10b981; 
            --action-dark: #059669;
            --danger: #ef4444;
            --border: #e2e8f0;
            --radius: 12px;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --touch-target: 48px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text-main);
            padding: 1rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Tabs / Mode Switcher */
        .mode-switch {
            display: flex;
            background: #e2e8f0;
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 400px;
        }
        .mode-btn {
            flex: 1;
            border: none;
            background: transparent;
            padding: 10px;
            border-radius: 8px;
            font-weight: 700;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-btn:hover { color: var(--text-main); }
        .mode-btn.active {
            background: var(--surface);
            color: var(--brand);
            box-shadow: 0 2px 4px rgb(0 0 0 / 0.05);
        }

        /* Layout Main */
        main { 
            width: 100%; 
            max-width: 600px; 
            display: grid; 
            gap: 1.5rem; 
        }

        @media (min-width: 800px) {
            main {
                max-width: 960px;
                grid-template-columns: 350px 1fr;
                align-items: start;
            }
            .preview-section { position: sticky; top: 1rem; }
        }

        .card {
            background: var(--surface);
            padding: 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        /* Canvas Area */
        .viewport {
            width: 100%;
            aspect-ratio: 1;
            background: #e5e5e5 radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            transition: border-color 0.2s;
            border: 2px solid transparent;
        }
        
        .viewport.drag-over { border-color: var(--brand); background-color: #eff6ff; }

        canvas { 
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            image-rendering: high-quality; /* Preview ainda usa nativo para velocidade */
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        video#sourceVideo { display: none; }
        
        .empty-msg {
            text-align: center; color: var(--text-muted); display: flex;
            flex-direction: column; align-items: center; gap: 0.5rem;
            font-size: 0.9rem; pointer-events: none;
        }

        /* Controls */
        fieldset { border: 0; display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem; }
        label { display: flex; justify-content: space-between; font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-main); }
        
        input[type="range"] {
            width: 100%; height: 24px; background: transparent; -webkit-appearance: none; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 6px; background: var(--border); border-radius: 4px; transition: background 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-runnable-track { background: #cbd5e1; }
        input[type="range"]::-webkit-slider-thumb {
            height: 24px; width: 24px; border-radius: 50%; background: var(--brand); 
            -webkit-appearance: none; margin-top: -9px; box-shadow: 0 2px 4px rgb(0 0 0 / 0.2);
            transition: transform 0.1s, background 0.2s;
        }
        input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.1); background: var(--brand-dark); }

        /* Buttons */
        .actions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-top: 0.5rem; }
        
        .btn {
            display: flex; align-items: center; justify-content: center; gap: 0.5rem;
            height: var(--touch-target); font-weight: 700; font-size: 0.95rem;
            border-radius: 8px; border: none; cursor: pointer; width: 100%;
            text-decoration: none; transition: all 0.2s;
        }
        .btn:active { transform: scale(0.97); }
        .btn:disabled { opacity: 0.7; cursor: wait; background: #94a3b8; }

        .btn-upload { background: var(--bg); color: var(--text-main); border: 1px solid var(--border); }
        .btn-upload:hover { background: #e2e8f0; border-color: #cbd5e1; }
        
        .btn-camera { background: var(--text-main); color: white; }
        .btn-camera:hover { background: #1e293b; }

        .btn-save { background: var(--action); color: white; margin-top: 1rem; font-size: 1.1rem; }
        .btn-save:hover { background: var(--action-dark); box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); }

        .btn-record { background: var(--danger); color: white; margin-top: 1rem; font-size: 1.1rem; }
        .btn-record:hover { background: #dc2626; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3); }
        
        .btn-sm { height: 36px; font-size: 0.8rem; background: var(--bg); border: 1px solid var(--border); transition: all 0.2s; }
        .btn-sm:hover { background: #e2e8f0; }
        .btn-sm.active { background: var(--brand); color: white; border-color: var(--brand); }

        .input-text {
            width: 100%; padding: 0.75rem; border: 1px solid var(--border);
            border-radius: 8px; font-size: 1rem; outline: none; transition: border-color 0.2s;
        }
        .input-text:focus { border-color: var(--brand); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }

        .hidden { display: none !important; }
        .file-input { display: none; }
        .val-badge { background: var(--bg); padding: 2px 6px; border-radius: 4px; font-variant-numeric: tabular-nums; font-size: 0.8em; color: var(--text-muted); }
        
        .rec-indicator {
            position: absolute; top: 10px; right: 10px;
            background: rgba(239, 68, 68, 0.9); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;
            display: flex; align-items: center; gap: 6px;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    </style>
</head>
<body>

    <div class="mode-switch">
        <button class="mode-btn active" id="modePhoto">FOTO HQ</button>
        <button class="mode-btn" id="modeVideo">VÍDEO HQ</button>
    </div>

    <main>
        <div class="card preview-section">
            <div class="viewport" id="dropZone">
                <div id="emptyState" class="empty-msg">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--border); margin-bottom: 0.5rem;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    <span>Arraste ou Cole</span>
                </div>
                <canvas id="canvas" class="hidden" width="300" height="300"></canvas>
                <div id="recBadge" class="rec-indicator hidden">REC</div>
            </div>

            <div class="actions-grid">
                <label class="btn btn-upload">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                    Arquivo
                    <input type="file" id="fileInput" class="file-input" accept="image/*">
                </label>
                
                <label class="btn btn-camera">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                    Câmera
                    <input type="file" id="cameraInput" class="file-input" accept="image/*" capture="environment">
                </label>
            </div>
        </div>

        <div class="card" id="controlsCard">
            <!-- IMAGE CONTROLS -->
            <div id="imageControls">
                <fieldset>
                    <label>Escala <span class="val-badge" id="scaleVal">85%</span></label>
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <button class="btn btn-sm active" id="btnFit">Fit</button>
                        <button class="btn btn-sm" id="btnMax">Full</button>
                        <button class="btn btn-sm" id="btnCenter">Centro</button>
                    </div>
                    <input type="range" id="scaleRange" min="50" max="200" value="85">
                </fieldset>

                <hr style="border: 0; border-top: 1px solid var(--border); margin: 1.5rem 0;">

                <fieldset>
                    <label>Cor / Luz</label>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 1rem; align-items: center;">
                        <span style="font-size: 0.8rem; color: var(--text-muted); width: 60px;">Brilho</span>
                        <input type="range" id="brightRange" min="-50" max="50" value="0">
                        <span style="font-size: 0.8rem; color: var(--text-muted); width: 60px;">Contraste</span>
                        <input type="range" id="contrastRange" min="-50" max="50" value="0">
                    </div>
                </fieldset>

                <fieldset style="background: #f0fdf4; padding: 1rem; border-radius: 8px; border: 1px solid #bbf7d0;">
                    <label style="color: #166534;">Nitidez Pro (3x) <span class="val-badge" id="sharpVal">0</span></label>
                    <input type="range" id="sharpRange" min="0" max="30" value="0" step="1">
                    <p style="font-size: 0.75rem; color: #166534; margin-top: 0.25rem;">Nível 10-15 recomendado para WebP</p>
                </fieldset>

                <button id="saveBtn" class="btn btn-save" disabled>
                    Baixar WebP Otimizado (30KB)
                </button>
            </div>

            <!-- VIDEO CONTROLS -->
            <div id="videoControls" class="hidden">
                <div style="background: #eff6ff; padding: 1rem; border-radius: 8px; border: 1px solid #bfdbfe; margin-bottom: 1.5rem;">
                    <p style="font-size: 0.85rem; color: #1e40af; text-align: center;">
                        <strong>Vídeo Mobile (Sem Áudio)</strong><br>
                        Recorte 300x300px com bitrate adaptativo.
                    </p>
                </div>
                
                <fieldset>
                    <label>Zoom do Vídeo <span class="val-badge" id="vScaleVal">100%</span></label>
                    <input type="range" id="vScaleRange" min="50" max="200" value="100">
                </fieldset>

                <button id="recordBtn" class="btn btn-record" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>
                    Gravar e Baixar
                </button>
                <div id="videoProgress" style="width: 0%; height: 4px; background: var(--action); margin-top: 10px; transition: width 0.2s; border-radius: 2px;"></div>
            </div>

            <div style="margin-top: 2rem; padding-top: 1rem; border-top: 1px dashed var(--border);">
                <label style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Nome do Arquivo (SEO)</label>
                <input type="text" id="nameInput" class="input-text" placeholder="ex: arroz-prato-fino" value="produto">
            </div>
        </div>
    </main>

    <video id="sourceVideo" muted playsinline crossorigin="anonymous"></video>

    <script>
        const state = {
            mode: 'photo',
            img: null, video: null,
            ctx: null, width: 300, height: 300,
            scale: 0.85, vScale: 1.0, x: 0, y: 0,
            recorder: null, chunks: [], isRecording: false,
            brightness: 0, contrast: 0, sharpness: 0
        };

        const els = {
            canvas: document.getElementById('canvas'),
            dropZone: document.getElementById('dropZone'),
            videoEl: document.getElementById('sourceVideo'),
            empty: document.getElementById('emptyState'),
            recBadge: document.getElementById('recBadge'),
            fileInput: document.getElementById('fileInput'),
            camInput: document.getElementById('cameraInput'),
            nameInput: document.getElementById('nameInput'),
            progressBar: document.getElementById('videoProgress'),
            mPhoto: document.getElementById('modePhoto'),
            mVideo: document.getElementById('modeVideo'),
            cPhoto: document.getElementById('imageControls'),
            cVideo: document.getElementById('videoControls'),
            scale: document.getElementById('scaleRange'),
            bright: document.getElementById('brightRange'),
            contrast: document.getElementById('contrastRange'),
            sharp: document.getElementById('sharpRange'),
            btnSave: document.getElementById('saveBtn'),
            vScale: document.getElementById('vScaleRange'),
            btnRec: document.getElementById('recordBtn')
        };

        function init() {
            els.canvas.width = 300;
            els.canvas.height = 300;
            els.ctx = els.canvas.getContext('2d', { willReadFrequently: true });
            
            els.mPhoto.onclick = () => setMode('photo');
            els.mVideo.onclick = () => setMode('video');
            els.fileInput.addEventListener('change', handleFile);
            els.camInput.addEventListener('change', handleFile);
            setupDragDrop();

            els.scale.oninput = (e) => { state.scale = e.target.value / 100; document.getElementById('scaleVal').innerText = e.target.value + '%'; requestRender(); };
            els.bright.oninput = (e) => { state.brightness = parseInt(e.target.value); requestRender(); };
            els.contrast.oninput = (e) => { state.contrast = parseInt(e.target.value); requestRender(); };
            els.sharp.oninput = (e) => { state.sharpness = parseInt(e.target.value); document.getElementById('sharpVal').innerText = e.target.value; requestRender(); };
            els.vScale.oninput = (e) => { state.vScale = e.target.value / 100; document.getElementById('vScaleVal').innerText = e.target.value + '%'; if(state.mode==='video') drawVideoFrame(); };

            els.btnSave.onclick = savePhotoHighQuality; // NOVA FUNÇÃO HQ
            els.btnRec.onclick = processVideo;

            els.canvas.addEventListener('mousedown', startPan);
            els.canvas.addEventListener('touchstart', (e) => startPan(e.touches[0]), {passive: false});
            window.addEventListener('mousemove', movePan);
            window.addEventListener('touchmove', (e) => movePan(e.touches[0]), {passive: false});
            window.addEventListener('mouseup', endPan);
            window.addEventListener('touchend', endPan);
            els.canvas.addEventListener('mouseleave', endPan);

            document.getElementById('btnFit').onclick = () => { els.scale.value=85; state.scale=0.85; requestRender(); updateActivePreset('btnFit'); };
            document.getElementById('btnMax').onclick = () => { els.scale.value=100; state.scale=1.0; requestRender(); updateActivePreset('btnMax'); };
            document.getElementById('btnCenter').onclick = () => { state.x=0; state.y=0; requestRender(); updateActivePreset('btnCenter'); };
            document.addEventListener('paste', handlePaste);
        }

        function updateActivePreset(id) {
            ['btnFit', 'btnMax', 'btnCenter'].forEach(b => document.getElementById(b).classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function setupDragDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => els.dropZone.addEventListener(ev, e => {e.preventDefault(); e.stopPropagation();}));
            ['dragenter', 'dragover'].forEach(ev => els.dropZone.addEventListener(ev, () => els.dropZone.classList.add('drag-over')));
            ['dragleave', 'drop'].forEach(ev => els.dropZone.addEventListener(ev, () => els.dropZone.classList.remove('drag-over')));
            els.dropZone.addEventListener('drop', e => { if(e.dataTransfer.files.length) handleFile({target: {files: e.dataTransfer.files}}); });
        }

        function handlePaste(e) {
            for (let item of e.clipboardData.items) {
                if (item.type.indexOf('image') !== -1) { loadImage(item.getAsFile()); break; }
            }
        }

        function setMode(mode) {
            state.mode = mode; state.x = 0; state.y = 0;
            els.canvas.width = 300; els.canvas.height = 300;
            els.ctx.fillStyle = '#fff'; els.ctx.fillRect(0,0,300,300);
            
            if(mode === 'photo') {
                els.mPhoto.classList.add('active'); els.mVideo.classList.remove('active');
                els.cPhoto.classList.remove('hidden'); els.cVideo.classList.add('hidden');
                els.fileInput.accept = "image/*"; els.camInput.accept = "image/*"; els.camInput.setAttribute('capture', 'environment');
            } else {
                els.mVideo.classList.add('active'); els.mPhoto.classList.remove('active');
                els.cVideo.classList.remove('hidden'); els.cPhoto.classList.add('hidden');
                els.fileInput.accept = "video/*"; els.camInput.accept = "video/*"; els.camInput.setAttribute('capture', 'environment');
            }
            els.empty.classList.remove('hidden'); els.canvas.classList.add('hidden');
        }

        function handleFile(e) {
            const file = e.target.files[0]; if(!file) return;
            if(file.type.startsWith('video/')) { if(state.mode !== 'video') setMode('video'); loadVideo(file); } 
            else { if(state.mode !== 'photo') setMode('photo'); loadImage(file); }
        }

        function loadImage(file) {
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                state.img = img; state.x = 0; state.y = 0;
                els.empty.classList.add('hidden'); els.canvas.classList.remove('hidden');
                els.btnSave.disabled = false; requestRender(); URL.revokeObjectURL(url);
            };
            img.src = url;
        }

        function requestRender() { requestAnimationFrame(renderPhoto); }

        // Renderização Rápida para Preview (Nativo)
        function renderPhoto() {
            if(!state.img) return;
            const ctx = els.ctx; const w = 300, h = 300;
            ctx.filter = 'none'; ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
            
            const aspect = state.img.width / state.img.height;
            let dw, dh, targetSize = w * state.scale;
            if (aspect > 1) { dw = targetSize; dh = targetSize / aspect; } else { dh = targetSize; dw = targetSize * aspect; }
            const dx = (w - dw)/2 + state.x; const dy = (h - dh)/2 + state.y;
            
            ctx.filter = `brightness(${100 + state.brightness}%) contrast(${100 + state.contrast}%)`;
            ctx.drawImage(state.img, dx, dy, dw, dh);
            ctx.filter = 'none';
            // Sharpen no preview é simplificado ou removido para performance em mobile fraco, 
            // mas podemos manter se necessário. Vou manter para feedback visual.
            if (state.sharpness > 0) applySharpen(ctx, w, h, state.sharpness); 
        }

        // --- SISTEMAS ENGINE HQ (SAVE) ---
        async function savePhotoHighQuality() {
            if (!state.img) return;
            const originalText = els.btnSave.innerText;
            els.btnSave.disabled = true;
            els.btnSave.innerHTML = "Gerando Super-Sampling...";

            try {
                // 1. Super-Sampling Canvas (900x900) - 3x Resolution
                // Renderizamos tudo 3x maior antes de reduzir com Lanczos
                const superSize = 900;
                const superCanvas = document.createElement('canvas');
                superCanvas.width = superSize;
                superCanvas.height = superSize;
                const sCtx = superCanvas.getContext('2d');

                sCtx.fillStyle = '#ffffff';
                sCtx.fillRect(0, 0, superSize, superSize);

                // Math x3
                const aspect = state.img.width / state.img.height;
                let dw, dh, targetSize = superSize * state.scale;
                if (aspect > 1) { dw = targetSize; dh = targetSize / aspect; } else { dh = targetSize; dw = targetSize * aspect; }
                const dx = (superSize - dw)/2 + (state.x * 3);
                const dy = (superSize - dh)/2 + (state.y * 3);

                sCtx.filter = `brightness(${100 + state.brightness}%) contrast(${100 + state.contrast}%)`;
                sCtx.drawImage(state.img, dx, dy, dw, dh);
                sCtx.filter = 'none';

                // 2. Lanczos3 Downscaling via Pica
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = 300;
                finalCanvas.height = 300;

                // Se o Pica falhar (rede offline), fallback nativo
                if (window.pica) {
                    await window.pica().resize(superCanvas, finalCanvas, {
                        unsharpAmount: 0, // Usaremos nosso sharpen customizado depois
                        unsharpRadius: 0.5,
                        unsharpThreshold: 0,
                        quality: 3 // Lanczos3 (Highest)
                    });
                } else {
                    // Fallback
                    console.warn("Pica not loaded, using native canvas");
                    const fCtx = finalCanvas.getContext('2d');
                    fCtx.drawImage(superCanvas, 0, 0, 300, 300);
                }

                // 3. Apply Custom Sharpen (CPU) on the 300x300 result
                // Aplicamos DEPOIS do resize para garantir que a nitidez seja "pixel perfect" no output final
                const fCtx = finalCanvas.getContext('2d');
                if (state.sharpness > 0) {
                    applySharpen(fCtx, 300, 300, state.sharpness);
                }

                // 4. Smart Compression (Binary Search)
                // Objetivo: Máxima qualidade que caiba em 30KB
                els.btnSave.innerHTML = "Otimizando 30KB...";
                const MAX_BYTES = 30720; // 30KB
                
                let minQ = 0.50; // Qualidade mínima aceitável
                let maxQ = 1.00;
                let bestBlob = null;

                // 6 iterações de busca binária são suficientes para precisão de ~1%
                for(let i=0; i<6; i++) {
                    const midQ = (minQ + maxQ) / 2;
                    const blob = await new Promise(r => finalCanvas.toBlob(r, 'image/webp', midQ));
                    
                    if (blob.size > MAX_BYTES) {
                        maxQ = midQ; // Muito grande, diminui qualidade
                    } else {
                        minQ = midQ; // Cabe! Tenta qualidade maior
                        bestBlob = blob; // Salva esse candidato válido
                    }
                }

                // Se nem a mínima qualidade couber (muito raro em 300x300), força a mínima
                if (!bestBlob) bestBlob = await new Promise(r => finalCanvas.toBlob(r, 'image/webp', 0.50));

                const url = URL.createObjectURL(bestBlob);
                download(url, '.webp');

            } catch (err) {
                console.error(err);
                alert("Erro ao processar imagem HQ.");
            }

            els.btnSave.disabled = false;
            els.btnSave.innerHTML = originalText;
        }

        function applySharpen(ctx, w, h, level) {
            const strength = (level / 10.0);
            if (strength <= 0.01) return;
            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            const output = ctx.createImageData(w, h);
            const dst = output.data;
            const wNeg = -strength; 
            const wCenter = 1 + (4 * strength);
            dst.set(data);
            for (let y = 1; y < h - 1; y++) {
                const rowOffset = y * w; const prevRow = (y - 1) * w; const nextRow = (y + 1) * w;
                for (let x = 1; x < w - 1; x++) {
                    const i = (rowOffset + x) * 4;
                    const iUp = (prevRow + x) * 4, iDown = (nextRow + x) * 4;
                    const iLeft = i - 4, iRight = i + 4;
                    for (let c = 0; c < 3; c++) {
                        const val = data[i + c];
                        const neighbors = data[iUp + c] + data[iDown + c] + data[iLeft + c] + data[iRight + c];
                        let res = (val * wCenter) + (neighbors * wNeg);
                        if (res < 0) res = 0; else if (res > 255) res = 255;
                        dst[i + c] = res;
                    }
                }
            }
            ctx.putImageData(output, 0, 0);
        }

        function loadVideo(file) {
            const url = URL.createObjectURL(file);
            els.videoEl.src = url;
            els.videoEl.onloadedmetadata = () => {
                state.video = els.videoEl; state.x = 0; state.y = 0;
                els.empty.classList.add('hidden'); els.canvas.classList.remove('hidden');
                els.btnRec.disabled = false; els.videoEl.currentTime = 0;
            };
            els.videoEl.loop = true; els.videoEl.muted = true; els.videoEl.play(); loopVideoPreview();
        }

        function loopVideoPreview() {
            if(state.mode !== 'video' || state.isRecording) return;
            drawVideoFrame(); requestAnimationFrame(loopVideoPreview);
        }

        function drawVideoFrame() {
            if(!state.video) return;
            const ctx = els.ctx; const w = 300, h = 300;
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
            const vw = state.video.videoWidth; const vh = state.video.videoHeight;
            const aspect = vw / vh;
            let dw, dh, targetSize = w * state.vScale;
            if (aspect > 1) { dw = targetSize; dh = targetSize / aspect; } else { dh = targetSize; dw = targetSize * aspect; }
            const dx = (w - dw)/2 + state.x; const dy = (h - dh)/2 + state.y;
            ctx.drawImage(state.video, dx, dy, dw, dh);
        }

        async function processVideo() {
            if(!state.video) return;
            state.isRecording = true;
            els.videoEl.pause(); els.videoEl.currentTime = 0; els.videoEl.loop = false;
            els.recBadge.classList.remove('hidden'); els.btnRec.disabled = true; els.btnRec.innerText = "Processando...";

            const stream = els.canvas.captureStream(30);
            const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
            const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 1000000 });
            const chunks = [];
            recorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob); download(url, '.webm');
                state.isRecording = false; els.recBadge.classList.add('hidden');
                els.btnRec.innerText = "Gravar e Baixar"; els.btnRec.disabled = false;
                els.videoEl.loop = true; els.videoEl.play(); loopVideoPreview();
            };
            recorder.start();
            try {
                await els.videoEl.play();
                function recordLoop() {
                    if(!state.isRecording) return;
                    if(els.videoEl.ended) { recorder.stop(); return; }
                    drawVideoFrame();
                    const pct = (els.videoEl.currentTime / els.videoEl.duration) * 100;
                    els.progressBar.style.width = pct + '%';
                    requestAnimationFrame(recordLoop);
                }
                recordLoop();
            } catch(e) { alert("Erro ao processar vídeo."); state.isRecording = false; els.recBadge.classList.add('hidden'); }
        }

        let isPanning = false, panStartX = 0, panStartY = 0;
        function startPan(e) {
            if((state.mode==='photo' && !state.img) || (state.mode==='video' && !state.video)) return;
            isPanning = true;
            panStartX = (e.clientX || e.pageX) - state.x; panStartY = (e.clientY || e.pageY) - state.y;
            els.canvas.style.cursor = 'grabbing';
        }
        function movePan(e) {
            if(!isPanning) return; if(e.cancelable) e.preventDefault();
            state.x = (e.clientX || e.pageX) - panStartX; state.y = (e.clientY || e.pageY) - panStartY;
            if(state.mode === 'photo') requestRender();
        }
        function endPan() { isPanning = false; els.canvas.style.cursor = 'grab'; }

        function download(url, ext) {
            const clean = (els.nameInput.value || 'produto').toLowerCase().replace(/[^a-z0-9]/g, '-');
            const link = document.createElement('a');
            link.download = clean + '-cesta-basica-cuiaba' + ext; link.href = url; link.click();
        }

        init();
    </script>
</body>
</html>
